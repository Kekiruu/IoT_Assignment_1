Designing and programming our MQTT-driven obstacle avoidance robot was a long process with many steps and challenges, but I was very proud of the result.

The first step was to figure out what the project was going to look like hardware-wise. From the get-go, I wanted the hardware side of the project to be as quick and easy as possible, while still yielding a cool, tangible final result. I like projects that I can see and touch, but this project seemed to be really about software, so I wanted us to be able to focus all of our efforts there.

We decided that for the physical device, we would re-use the old Elegoo robot car from the first semester, since it had everything that we need for a microcontroller to control motors & sensors, in a familiar and reliable package. I happen to have laying around an ESP8266 board that is shaped exactly like an Arduino Uno, so my original idea was to just plug that ESP board into the robot's shield meant for an Arduino Uno, to securly connect the ESP's IO pins to the robot components. Unfortunately though, the pinout of this ESP board is not the same as the pinout that the shield is designed for, so plugging it into the shield would cause power pins to get shorted. The next option was to take advantage of the connection point on top of the shield for the Uno's UART (Serial) pins. This allows us to leave the Arduino Uno in the robot, and have an ESP board command the arduino via their RX and TX pins. This made for a very easy hardware implementation, since we just have to use a mini ESP8266 board with its RX and TX connected to the Uno's TX and RX, plus VCC and GND, and all the rest of the wiring is already done. 

Next came the software. Because the project had 3 programmable devices that needed to work together, the programming quickly became way more complicated than I was expecting.

Before writing the full obstacle avoiding code in the Raspberry Pi, we needed a robot that could act based upon MQTT messages that it reads. We decided to use the Arduino IDE to program the ESP8266, partly because I had a terrible time the last time I tried using microPython in an ESP8266 (and using an ESP32 in this project wouldn't be ideal since the one I have is much bigger than my 8266's), and partly because we're more familiar with using arduino C code to control GPIOs compared to microPython. I quickly found an MQTT library for ESPs, and setting up the topics for communication with the Pi was straightforward. By far the hardest part of the robot side of the code was getting the ESP to communicate with the Arduino in the robot. At a basic level, using the UART protocol is very easy. You send one byte at a time out of one microcontroller's TX pin, and the other uC receives that byte on its RX pin. We had a relatively easy time creating a manual control system for our robot, which works as follows: a button is pressed on the website by the user, which causes the Pi to publish one of 5 movement strings, which the ESP receives; based on this message, the ESP sends a byte from 0-4 over UART to the Arduino, which then moves forward, back, left, right, or stops, based on the value. This manual control only involves 1-way communication, and no timing, so it was pretty simple to implement.

The two-way communication and timing needed for obstacle avoidance is where things quickly got complicated. At times I started to think that, maybe I should've just put more effort into the hardware, in order for the robot to work with only an ESP. We devised a system where the obstacle avoidance was initiated by the Pi publishing a command for driving movement and a command for ultrasonic sensor scanning. The ESP then reacts to this by asking the Arduino to A: move in the requested direction, just like with manual movement; and B: turn the ultrasonic sensor to one of 3 directions requested by the Pi, and return a distance measurement. The ESP then publishes this measurement back to the Raspberry Pi, which then makes a decision and publishes another movement and sensor command back to the ESP. This back-and-forth communication happens over and over as long as the Raspberry Pi's AutoMode variable is true; otherwise, it will not reply to a publication from the ESP, and the back-and-forth stops until the Pi initiates it again. In terms of timed events, the timing code is split across the ESP and the Arduino, so the Raspberry Pi does not need to directly manage the duration of timed movements, in case of bad network connection. The ESP takes care of timing the robot rotation to turn away from obstacles, and the Arduino waits for the servo to finish spinning to the target angle before pinging the ultrasonic sensor.

On the Raspberry Pi's end, our code was mostly an evolution of the Python programs we made during the lab periods. We re-used the historian page to see the messages in the ultrasonic sensor topic, and we improved on our manual publication page in order to publish movement messages from on-screen buttons and toggle obstacle mode. For the obstacle avoidance algorithm, we orignially wanted to use the rules json file for a clear namespace in which to create rules for the different possible actions in obstacle avoidance mode. However, as Hai and I deliberated about how the algorithm must work, we realized that the rules system was limiting, since only one action could be triggered per rule. We could have modified the python code that parsed the rules, or we could have made duplicate rules with the same conditions but a different action. In the end though, we decided to just abandon the rules system and hardcode the obstacle avoidance algorithm into the old IoT controller program. The algorithm consisted of a series of if statements in the on_message method of the IoT controller obect, which published decisions based on the latest distance measurement  received from the ESP, as well as previously stored distance measurements. We realized that the code inside the on_message function could execute at any time, regardless of blocking delays in the rest of the program, so this function was quite useful for the Pi to react immediately to whatever the ESP publishes. The obstacle avoidance took some testing and troubleshooting to get working, since there were a lot of conditions that had to line up for each step in the algorithm to execute in a back-and-forth communication with the ESP. 
